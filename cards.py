import util
import copy


class ImperialSummoningCard:
    '''
    An instance of a card used to summon a common/heroic being. Consists of two main parts:
        - check if the card is valid given the state of the game
        - if valid, execute associated actions with a given sequence of commands
    '''

    def __init__(self,card_ID):
        assert card_ID <= util.NUM_CARDS and card_ID >= 1, "card_ID number out of range"

        # numeral identifier of a card, from 1-18
        self.card_ID = card_ID
        self.rank = util.COMMON

        # threshold of common vs heroic beings
        if self.card_ID > 5: self.rank = util.HEROIC

        # self.formation:
        # a list of tuples, representing the formation for the being
        # first element is always (0,0), some arbitrary datum in the formation
        # datum is generally picked as the furthest left piece on the bottom row on the card
        # additional elements are measured relative to the datum in (+a,+b) fashion
        #   - e.g. swordmaster: [(0,0),(0,2),(0,1)] -  with the lower piece on the card
        #           as the datum, and a second piece two squares higher
        # the last element is where the being is summoned

        # the list of formations should retain its order, to match with associated vectors

        # self.vector: an indicator of some power specific to a particular card
        # only five cards have a vector (the rest are indicated by the empty string "")
        #   - 6 Assassin - NW (direction of assassinated square)
        #   - 7 Time Mage - SW (direction of destroyed square)
        #   - 8 Summoner - N (direction of summoning field)
        #   - 10 Cannon - E (primary firing direction)
        #   - 11 Gun Tower - E (primary firing direction)

        if card_ID == 1:
            self.name = "Swordmaster"
            self.formation = [(0,0),(0,2),(0,1)]
            self.vector = ""
        elif card_ID == 2:
            self.name = "Messenger"
            self.formation = [(0,0),(-1,1),(-2,2)]
            self.vector = ""
        elif card_ID == 3:
            self.name = "Herald"
            self.formation = [(0,0),(0,1),(1,1),(-1,2)]
            self.vector = ""
        elif card_ID == 4:
            self.name = "Bomb"
            self.formation = [(0,0),(0,1),(-1,2)]
            self.vector = ""
        elif card_ID == 5:
            self.name = "Chronicler"
            self.formation = [(0,0),(1,1),(2,0),(1,0)]
            self.vector = ""
        elif card_ID == 6:
            self.name = "Assassin"
            self.formation = [(0,0),(1,1),(2,2),(3,-1)]
            self.vector = "NW"
        elif card_ID == 7:
            self.name = "Time Mage"
            self.formation = [(0,0),(-1,1),(0,2),(1,1),(1,2)]
            self.vector = "SW"
        elif card_ID == 8:
            self.name = "Summoner"
            self.formation = [(0,0),(1,0),(2,0),(1,1)]
            self.vector = "N"
        elif card_ID == 9:
            self.name = "Hypnotist"
            self.formation = [(0,0),(0,1),(2,1),(2,2),(1,1)]
            self.vector = ""
        elif card_ID == 10:
            self.name = "Cannon"
            self.formation = [(0,0),(1,1),(2,1),(2,1)]
            self.vector = "E"
        elif card_ID == 11:
            self.name = "Champion"
            self.formation = [(0,0),(0,1),(-1,1),(-1,2),(0,2)]
            self.vector = ""
        elif card_ID == 12:
            self.name = "Infantry Captain"
            self.formation = [(0,0),(1,0),(3,0),(4,0),(2,1)]
            self.vector = ""
        elif card_ID == 13:
            self.name = "Cavalry Captain"
            self.formation = [(0,0),(0,1),(2,0),(2,1),(1,2)]
            self.vector = ""
        elif card_ID == 14:
            self.name = "Gryphon Rider"
            self.formation = [(0,0),(-1,1),(-2,2),(-3,1),(-1,2)]
            self.vector = ""
        elif card_ID == 15:
            self.name = "Knight"
            self.formation = [(0,0),(0,1),(1,1),(2,1),(1,2)]
            self.vector = ""
        elif card_ID == 16:
            self.name = "High Priestess"
            self.formation = [(0,0),(1,2),(2,0),(1,2)]
            self.vector = ""
        elif card_ID == 17:
            self.name = "Master of Intrigue"
            self.formation = [(0,0),(0,2),(2,2),(2,0),(1,1)]
            self.vector = ""
        elif card_ID == 18:
            self.name = "Gun Tower"
            self.formation = [(0,0),(0,1),(1,1),(1,0),(0,2)]
            self.vector = "E"

        # 8 cardinal directions, representing the possible directions from a square
        # maybe don't need this variable...
        self.directions = util.CARDINAL_DIRECTIONS

    # returns a tuple of (formations,vectors):
    #
    #   formations:
    # starting with the initial formation, a list of 8 formations
    # generated by rotating the initial formation 3 times, by mirroring the
    # initial formation about the vertical axis, and rotating that 3 more times
    # all formations are in refernece to some arbitrary datum (0,0)
    #
    # order of formations is critical to match vectors, and depending on the symmetry of the 
    # formation, there may be duplicates in the list
    #   - a formation is a list of tuples (see initialization of self.formation)
    #
    #   vectors:
    # a list of 8 cardinal directions, with an order matching the formations list
    # the vector at index i tracks with the formation in formations at index i
    #   - e.g. the assassin defaults to 'NW' (direction of destroyed square)
    #     but after a CW rotation it would be 'N', or after mirroring it would be 'NE'
    def allFormations(self):
        # rotates a formation tuple clockwise about (0,0)
        rotateCW = lambda input: ( input[1],-1*input[0] )

        # mirrors a tuple about a vertical axis through (0,0)
        mirror = lambda input: ( -1*input[0],input[1] )

        # begin lists with the original formation & vector
        vectors = []
        formations = []
        formations.append(self.formation)
        vectors.append(self.vector)

        # add the mirrored formation & vector
        mirrored_vector = util.mirrorDirection(self.vector)
        mirrored_formation = []
        for i in range(len(self.formation)):
            mirrored_formation.append(mirror(self.formation[i]))
        formations.append(mirrored_formation)
        vectors.append(mirrored_vector)

        # set up the holding variables
        prev_formation = self.formation
        prev_formation_mirrored = mirrored_formation
        prev_vector = self.vector
        prev_mirrored_vector = mirrored_vector

        # rotate everything three times
        for n_rotations in range(3):
            # rotate the vectors
            rotated_vector = util.rotateDirectionCW(prev_vector)
            rotated_mirrored_vector = util.rotateDirectionCW(prev_mirrored_vector)
            # rotate the formations
            rotated = []
            rotated_mirrored = []
            for i in range(len(self.formation)):
                rotated.append(rotateCW(prev_formation[i]))
                rotated_mirrored.append(rotateCW(prev_formation_mirrored[i]))

            # add the formations & vectors - in order!!
            formations.append(rotated)
            formations.append(rotated_mirrored)
            vectors.append(rotated_vector)
            vectors.append(rotated_mirrored_vector)

            # update the holding variables
            prev_formation = rotated
            prev_formation_mirrored = rotated_mirrored
            prev_vector = rotated_vector
            prev_mirrored_vector = rotated_mirrored_vector
        return (formations,vectors)



    # some print function to display formation & associated actions?
    def printDetails(self):
        print ("%s: Rank %d" % (self.name,self.rank))

    '''
    returns a set of (x,y,vector) tuples representing the location of all valid summonings
    x,y are the cartesian coordinates
    vector is a string, either
        - "N", "S", "E", "W"
        - "NW", "NE", "SW", "SE"
        - "" (for when a vector is unnecessary)
    vectors are required on certain cards (#6,7,8,10,18) in addition to the location of the summoned being

        - player is the number of the current player
        - player_pieces is a list of pieces belonging to the current player - (x,y,rank)
        - board is the matrix of all the pieces on the board - access via board[x][y] = (player,piece_rank)
    '''
    def getPossibleLocations(self,player,player_pieces,board):
        result = set()
        for piece in player_pieces:
            piece_x = piece[0]
            piece_y = piece[1]

            possible_formations = self.allFormations()
            formations = possible_formations[0]
            vectors = possible_formations[1]
            # check each of 8 formations
            for formation in formations:
                # check each tuple in the formation for player ownership, except for the summoning square
                # for the last tuple (summoning square), enforce equal or lesser rank
                valid_formation = True
                for i in range(len(formation)):
                    form_piece = formation[i]
                    new_x = piece_x + form_piece[0]
                    new_y = piece_y + form_piece[1]
                    if not util.validCoordinates(new_x,new_y):
                        valid_formation = False
                        break
                    check_piece = board[new_x][new_y]

                    # summoning square
                    if i == len(formation)-1:
                        if check_piece[1] > self.rank:
                            valid_formation = False
                            break
                        continue

                    # pattern square
                    if check_piece[0] != player:
                        valid_formation = False
                        break
                if valid_formation:
                    vector = vectors[formations.index(formation)]
                    summoning_square = formation[len(formation)-1]
                    #print "previous rank at summoning square: ",board[piece_x + summoning_square[0]][piece_y + summoning_square[1]][1]
                    result.add((piece_x + summoning_square[0],piece_y + summoning_square[1],vector))
        return result

    # returns a list of action tuples based on all possible locations of the card
    # Summon actions: ('Summon',ID,(x,y,vector),...)
    # NOTE: ... follow up arguments dependent on card ID
    def getSummonActions(self,player,player_pieces,board):

        # each of the following helper functions, 1 per card ID, take in
        # x,y coordinates of the summoned being & the associated vector
        # and returns a list of lists: all permutations of player-controlled follow-up actions
        # the empty string "" in the domain indicates a "do nothing" follow-up
        # an empty list [] indicates there are no player-controlled follow up actions

        # check for enemy common pieces on the 4 diag adjacent corners
        # domain = ["","NW","NE","SE","SW"]
        def swordmaster01(summon_x,summon_y,vector):
            fup = [[""]]
            def enemyCommon(coordinate):
                (x,y) = coordinate
                if not util.validCoordinates(x,y): return False
                if board[x][y][0] == -1*player and board[x][y][1] == util.COMMON:
                    return True
                else: return False
            if enemyCommon(util.getAdjacent(summon_x,summon_y,"NE")): fup.append(["NE"])
            if enemyCommon(util.getAdjacent(summon_x,summon_y,"SE")): fup.append(["SE"])
            if enemyCommon(util.getAdjacent(summon_x,summon_y,"SW")): fup.append(["SW"])
            if enemyCommon(util.getAdjacent(summon_x,summon_y,"NW")): fup.append(["NW"])
            return fup

        # no player controlled follow ups
        def bomb04(summon_x,summon_y,vector):
            return []

        # if the adjacent square in direction "vector" is empty, the assassin may
        # move there - domain = ["",vector]
        def assassin06(summon_x,summon_y,vector):
            fup = [[""]]
            (x,y) = util.getAdjacent(summon_x,summon_y,vector)
            if not util.validCoordinates(x,y): return fup
            if board[x][y][0] == util.EMPTY: fup.append([vector])
            return fup

        # no player controlled follow-ups
        def timeMage07(summon_x,summon_y,vector):
            return []

        # 8 possible actions: all directions except the one directly behind the cannon,
        # and do nothing
        def cannon10(summon_x,summon_y,vector):
            fup = [[""]]
            for direction in util.CARDINAL_DIRECTIONS:
                if direction == util.rotateDirection180(vector): continue
                fup.append([direction])
            return fup

        # 6 possible actions: 5 adjacent squares that could belong to the enemy, do nothing
        def champion11(summon_x,summon_y,vector):
            fup = [[""]]
            for direction in util.CARDINAL_DIRECTIONS:
                (x,y) = util.getAdjacent(summon_x,summon_y,direction)
                if board[x][y][0] == -1*player: fup.append([direction])
            return fup

        # 3 possible actions: primary direction, 180deg rotated, and do nothing
        def gunTower18(summon_x,summon_y,vector):
            fup = [[""]]
            fup.append([vector])
            fup.append([util.rotateDirection180(vector)])
            return fup

        result = []
        possibleLocations = self.getPossibleLocations(player,player_pieces,board)
        for (x,y,vector) in possibleLocations:
            follow_up_actions = []
            if self.card_ID == 1: follow_up_actions = swordmaster01(x,y,vector)
            if self.card_ID == 4: follow_up_actions = bomb04(x,y,vector)
            if self.card_ID == 6: follow_up_actions = assassin06(x,y,vector)
            if self.card_ID == 7: follow_up_actions = timeMage07(x,y,vector)
            if self.card_ID == 10: follow_up_actions = cannon10(x,y,vector)
            if self.card_ID == 11: follow_up_actions = champion11(x,y,vector)
            if self.card_ID == 18: follow_up_actions = gunTower18(x,y,vector)
            prefix = ["Summon",self.card_ID,(x,y,vector)]
            if follow_up_actions == []: result.append(tuple(prefix))
            for follow_up_args in follow_up_actions:
                result.append(tuple(prefix + follow_up_args))

        return result

    # this function executes a summon action ONLY according to the specific
    # follow-up powers of a card.
    # NOTE: this function does not handle resolutions applicable to all summons,
    # like destroying a piece present on the summoning square, or summoning the being
    # of that rank
    # returns True if successful, otherwise False
    def executeSummonAction(self,action,tk):

        # if indicated, destroys an enemy common piece diagonally adjacent to the
        # summoned square, then upgrades the summoned piece to heroic
        def swordmaster01(summon_x,summon_y,vector):
            fup1 = action[3]
            if fup1 == "": return True
            (des_x,des_y) = util.getAdjacent(summon_x,summon_y,fup1)
            assert tk.board[des_x][des_y][0] == -1*tk.current_player and tk.board[des_x][des_y][1] == util.COMMON
            tk.removePiece(des_x,des_y)
            tk.pieces_destroyed[0] += 1
            tk.placePiece(tk.current_player,util.HEROIC,summon_x,summon_y)
            return True

        # if the bomb is the last action of the turn, it's a dud
        # otherwise, destroy the bomb and all adjacent common pieces
        def bomb04(summon_x,summon_y,vector):
            # last action: nothing happens
            if tk.remaining_game_actions == 1: return True

            for direction in util.CARDINAL_DIRECTIONS:
                (des_x,des_y) = util.getAdjacent(summon_x,summon_y,direction)
                if not util.validCoordinates(des_x,des_y): continue
                if tk.board[des_x][des_y][1] == util.COMMON:
                    if tk.board[des_x][des_y][0] == -1*tk.current_player:
                        tk.pieces_destroyed[0] += 1
                    tk.removePiece(des_x,des_y)
            # self destruct
            tk.removePiece(summon_x,summon_y)
            return True

        # destroys any piece present on the square 'vector' from summon_x,summon_y
        # moves the assassin to that square, if indicated
        def assassin06(summon_x,summon_y,vector):
            (des_x,des_y) = util.getAdjacent(summon_x,summon_y,vector)
            was_empty = (des_x,des_y) in tk.empty_squares
            if tk.board[des_x][des_y][0] == -1*tk.current_player:
                if tk.board[des_x][des_y][1] == util.COMMON: tk.pieces_destroyed[0] += 1
                elif tk.board[des_x][des_y][1] == util.HEROIC: tk.pieces_destroyed[1] += 1
            tk.removePiece(des_x,des_y)
            fup1 = action[3]
            if fup1 == "": return True
            assert fup1 == vector
            assert was_empty, "assassin can't jump back unless the square was empty before"
            # jump back (standard move)
            tk.removePiece(summon_x,summon_y)
            tk.placePiece(tk.current_player,self.rank,des_x,des_y)
            return True

        # gain an action, destroy any enemy piece on the square 'vector' from summon_x,summon_y
        def timeMage07(summon_x,summon_y,vector):
            tk.remaining_game_actions += 1

            (des_x,des_y) = util.getAdjacent(summon_x,summon_y,vector)
            if tk.board[des_x][des_y][0] == -1*tk.current_player:
                if tk.board[des_x][des_y][1] == util.COMMON: tk.pieces_destroyed[0] += 1
                elif tk.board[des_x][des_y][1] == util.HEROIC: tk.pieces_destroyed[1] += 1
                # only destroy enemy pieces
                tk.removePiece(des_x,des_y)
            return True

        # destroy all common pieces in the direction indicated by the action (NOT vector)
        def cannon10(summon_x,summon_y,vector):
            fup1 = action[3]
            (old_x,old_y) = (summon_x,summon_y)
            while True:
                (des_x,des_y) = util.getAdjacent(old_x,old_y,fup1)
                # go up to edge of the board
                if not util.validCoordinates(des_x,des_y): return True
                if tk.board[des_x][des_y][1] == util.COMMON:
                    if tk.board[des_x][des_y][0] == -1*tk.current_player:
                        tk.pieces_destroyed[0] += 1
                    tk.removePiece(des_x,des_y)
                (old_x,old_y) = (des_x,des_y)
            return True

        # destroy an adjacent enemy pieces, if indicated by the action (NOT vector)
        def champion11(summon_x,summon_y,vector):
            fup1 = action[3]
            if fup1 == "": return True
            (des_x,des_y) = util.getAdjacent(summon_x,summon_y,fup1)
            assert tk.board[des_x][des_y][0] == -1*tk.current_player, "champion can't destroy an empty square or its own team"
            if tk.board[des_x][des_y][1] == util.COMMON: tk.pieces_destroyed[0] += 1
            elif tk.board[des_x][des_y][1] == util.HEROIC: tk.pieces_destroyed[1] += 1
            tk.removePiece(des_x,des_y)
            return True

        # destroy the first two pieces in the direction indicated by the action (NOT vector)
        def gunTower18(summon_x,summon_y,vector):
            fup1 = action[3]
            if fup1 == "": return True
            kill_count = 0
            (old_x,old_y) = (summon_x,summon_y)
            while True:
                (des_x,des_y) = util.getAdjacent(old_x,old_y,fup1)
                # go up to edge of the board
                if not util.validCoordinates(des_x,des_y): return True
                if tk.board[des_x][des_y][0] != EMPTY:
                    kill_count += 1
                    if tk.board[des_x][des_y][0] == -1*tk.current_player:
                        if tk.board[des_x][des_y][1] == util.COMMON: tk.pieces_destroyed[0] += 1
                        elif tk.board[des_x][des_y][1] == util.HEROIC: tk.pieces_destroyed[1] += 1
                    tk.removePiece(des_x,des_y)
                if kill_count == 2: return True
            return True

        executeHelper = lambda summon_x,summon_y,vector: False
        if self.card_ID == 1: executeHelper = swordmaster01
        if self.card_ID == 4: executeHelper = bomb04
        if self.card_ID == 6: executeHelper = assassin06
        if self.card_ID == 7: executeHelper = timeMage07
        if self.card_ID == 10: executeHelper = cannon10
        if self.card_ID == 11: executeHelper = champion11
        if self.card_ID == 18: executeHelper = gunTower18

        (x,y,vector) = action[2]
        return executeHelper(x,y,vector)

